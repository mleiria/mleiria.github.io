---
layout: post
title:  Métodos Numéricos - Bisecção
date:   2021-05-03 13:00:00
---

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<h2>Introdução</h2>
<p>O método da Bisecção é um método numérico que permite calcular o valor (aproximado) das raizes de uma equação não linear.</p>
Para garantir a solução, usando este método, as seguintes condições têm de se verificar:
<p>
	<ol>
		<li><i>f</i> contínua em <i>[a, b]</i></li>
		<li><i>f(a)f(b) < 0</i></li>
		<li>Só existe um zero no interior do intervalo <i>[a, b]</i></li>
	
</ol>
</p>
<p>
	As condições (1) e (2) sugerem-nos um processo bastante simples para obter uma aproximação do zero de uma função. Supondo que só existe um zero da função <i>f</i> no interior do intervalo
	<i>[a, b]</i> (condição (3)), o processo consiste em dividir o intervalo dado ao meio e testar de novo a condição (2) nos subintervalos \[ [a, \frac{a + b}{2}]\] e \[ [ \frac{a + b}{2}, b] \]
	para determinar qual deles contém a raiz. O processo é repetido para o novo subintervalo até que se obtenha uma precisão prefixada.

</p>
<h2>Pseudocódigo</h2>
<strong>Condição suficiente de convergência do método</strong><p>
<i>- f contínua em [a, b]</i><br>
<i>- f(a)f(b) < 0</i><p>
<strong>Inicialização</strong><p>
<i>a<sub>0</sub> = a, b<sub>0</sub> = b, x<sub>0</sub> = a ou x<sub>0</sub> = b</i><p>
<strong>Ciclo</strong><p>
Para \[ m \ge 0 \] fazer \[ x_{m+1} = \frac{a_m + b_m}{2}\]
Se \( |x_{m+1} - x_m | \le \epsilon \) ou \( |f(x_{m+1})| \le \epsilon \) <p>
então fazer <i>x<sub>m+1</sub></i> e retornar. <p>
Caso contrário: <p>
Se \[ f(x_{m+1})f(a_m) < 0\] então fazer:<p> \( a_{m+1} = a_m \) e \( b_{m+1} = x_{m+1} \)<p>
Se não fazer: <p>
\(a_{m+1} = x_{m+1} \) e \(b_{m+1} = b_m \)<p>

<h2>Implementação em Java</h2>
Consideremos a seguinte função:
\[ f(x) = x^3 - x - 2.0\]

e queremos encontrar o zero da funçaõ dentro do intervalo <i>[1.0, 2.0]</i>
<img src="../images/2021-05-03-Metodos_Numericos-Biseccao_1.png"><p>

<h3>Estilo imperativo</h3>
<pre>
package pt.mleiria.numericalmethods.rootfinder;

import java.util.Optional;
import java.util.function.*;

/**
 * Condições a verificar:
 * 1. f contínua em [a,b]
 * 2. f(a)f(b) < 0
 * 3. QUalquer que x pertencente a ]a,b[ , f'(x) != 0
 */
public class BissectionImperative {

    private final double a;
    private final double b;
    private final ToDoubleFunction<Double> f;
    private final double epsilon;
    private final long maxIter;

    private double am;
    private double bm;
    private double xm, xm1;

    /**
     * Condição suficiente de convergência do método:
     * - f contínua em [a,b]
     * - f(a)f(b) < 0
     */
    public BissectionImperative(final double a, final double b, ToDoubleFunction<Double> f,
                                final double epsilon, final long maxIter) {
        this.a = a;
        this.b = b;
        this.f = f;
        this.epsilon = epsilon;
        this.maxIter = maxIter;
        init();
    }

    private void init() {
        am = a;
        bm = b;
        xm = a;
    }

    ToDoubleBiFunction<Double, Double> step = (elem1, elem2) -> (elem1 + elem2) / 2.0;

    public Optional<Double> findRoot() {
        for (int i = 0; i < maxIter; i++) {
            xm1 = step.applyAsDouble(am, bm);
            double tmp = Math.abs(xm1 - xm);
            double tmp1 = Math.abs(f.applyAsDouble(xm1));

            if (tmp <= epsilon || tmp1 <= epsilon) {
                return Optional.of(xm1);
            } else {
                if ((f.applyAsDouble(xm1) * f.applyAsDouble(am)) < 0) {
                    bm = xm1;
                } else {
                    am = xm1;
                }
                System.out.printf("%d    %.12f    %.12f    %n", i, xm, f.applyAsDouble(xm));
                xm = xm1;
            }
        }
        return Optional.empty();
    }



    public static void main(String[] args) {
        ToDoubleFunction<Double> f = elem -> Math.pow(elem, 3) - elem - 2.0;
        double a = 1.0;
        double b = 2.0;
        double epsilon = 0.0000001;
        BissectionImperative bissectionImperative = new BissectionImperative(a, b, f, epsilon, 100);
        //1.521484375
        System.out.println(bissectionImperative.findRoot());
    }
}

</pre>
<p>
<pre>
0    1.000000000000    -2.000000000000    
1    1.500000000000    -0.125000000000    
2    1.750000000000    1.609375000000    
3    1.625000000000    0.666015625000    
4    1.562500000000    0.252197265625    
5    1.531250000000    0.059112548828    
6    1.515625000000    -0.034053802490    
7    1.523437500000    0.012250423431    
8    1.519531250000    -0.010971248150    
9    1.521484375000    0.000622175634    
10    1.520507812500    -0.005178886466    
11    1.520996093750    -0.002279443317    
12    1.521240234375    -0.000828905861    
13    1.521362304688    -0.000103433124    
14    1.521423339844    0.000259354252    
15    1.521392822266    0.000077956314    
16    1.521377563477    -0.000012739468    
17    1.521385192871    0.000032608157    
18    1.521381378174    0.000009934278    
19    1.521379470825    -0.000001402611    
20    1.521380424500    0.000004265829    
Optional[1.5213797092437744]
</pre>
</p>
<h3>Estilo funcional</h3>
<pre>
package pt.mleiria.numericalmethods.rootfinder;

import java.util.Optional;
import java.util.function.BiPredicate;
import java.util.function.Predicate;
import java.util.function.ToDoubleBiFunction;
import java.util.function.ToDoubleFunction;

public class Bissection {

    private static final double epsilon = 1E-10;
    private static final long maxIter = 100;
    /**
     * Step condition
     */
    private static ToDoubleBiFunction<Double, Double> step = (elem1, elem2) -> (elem1 + elem2) / 2.0;


    private static Optional<Double> findRoot(final ToDoubleFunction f, final double am, final double bm,
                                             final double xm, final long cnt) {
        System.out.printf("%d    %.12f    %.12f    %n", cnt, xm, f.applyAsDouble(xm));
        if (cnt == maxIter) {
            return Optional.empty();
        }
        final double xm1 = step.applyAsDouble(am, bm);
        final BiPredicate<Double, Double> foundCondition = (elem1, elem2) -> elem1 <= epsilon || elem2 <= epsilon;
        final Predicate<Double> iterateCondition = elem -> elem < 0;

        if (foundCondition.test(Math.abs(xm1 - xm), Math.abs(f.applyAsDouble(xm1)))) {
            return Optional.of(xm1);
        } else {
            if (iterateCondition.test(f.applyAsDouble(xm1) * f.applyAsDouble(am))) {
                return findRoot(f, am, xm1, xm1, cnt + 1);
            } else {
                return findRoot(f, xm1, bm, xm1, cnt + 1);
            }
        }
    }

    /**
     * @param f
     * @param am
     * @param bm
     * @return the root of the function or empty
     */
    public static Optional<Double> findRoot(final ToDoubleFunction f, final double am, final double bm) {
        return findRoot(f, am, bm, am, 0);
    }

    public static void main(String[] args) {
        final ToDoubleFunction<Double> f = x -> Math.pow(x, 3) - x - 2.0;
        System.out.println(Bissection.findRoot(f, 1.0, 2.0));

    }
}

</pre>
<p>
<pre>
0    1.000000000000    -2.000000000000    
1    1.500000000000    -0.125000000000    
2    1.750000000000    1.609375000000    
3    1.625000000000    0.666015625000    
4    1.562500000000    0.252197265625    
5    1.531250000000    0.059112548828    
6    1.515625000000    -0.034053802490    
7    1.523437500000    0.012250423431    
8    1.519531250000    -0.010971248150    
9    1.521484375000    0.000622175634    
10    1.520507812500    -0.005178886466    
11    1.520996093750    -0.002279443317    
12    1.521240234375    -0.000828905861    
13    1.521362304688    -0.000103433124    
14    1.521423339844    0.000259354252    
15    1.521392822266    0.000077956314    
16    1.521377563477    -0.000012739468    
17    1.521385192871    0.000032608157    
18    1.521381378174    0.000009934278    
19    1.521379470825    -0.000001402611    
20    1.521380424500    0.000004265829    
21    1.521379947662    0.000001431608    
22    1.521379709244    0.000000014498    
23    1.521379590034    -0.000000694057    
24    1.521379649639    -0.000000339779    
25    1.521379679441    -0.000000162641    
26    1.521379694343    -0.000000074071    
27    1.521379701793    -0.000000029787    
28    1.521379705518    -0.000000007644    
29    1.521379707381    0.000000003427    
30    1.521379706450    -0.000000002109    
31    1.521379706915    0.000000000659    
32    1.521379706683    -0.000000000725    
Optional[1.5213797067990527]
</pre>



